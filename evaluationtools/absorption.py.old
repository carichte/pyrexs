#!/usr/bin/env python
#
#
# this is part of the 'evaluationtools' set written by Carsten Richter
# (carsten.richter@desy.de)
#

import os
import evaluationtools as et
import pyxrr.functions as pf
#import mskk
import numpy as np
from pyxrr import wrap4leastsq
from scipy import interpolate, ndimage, optimize

"""
def mud_to_f2(element, energy, mud, smooth=3):
    Etab, f1tab, f2tab = pf.get_f1f2_from_db(element, table='Sasaki').T
    f1tab-= pf.get_element(element)[-1]
    f1func = interpolate.interp1d(Etab, f1tab)
    f2func = interpolate.interp1d(Etab, f2tab)
    nEtab = np.arange(Etab[0], Etab[-1], np.diff(Etab).min())
    f2tab = ndimage.gaussian_filter1d(f2func(nEtab), smooth)
    f2func = interpolate.interp1d(nEtab, f2tab)
    
    
    f2m = mud * energy
    
    iKtab = np.diff(f2tab).argmax()
    Ektab = nEtab[[iKtab, iKtab+1]].mean()
    iK = np.diff(f2m).argmax()
    Ek = energy[[iK, iK+1]].mean()
    print("Edge Energy: %f"%Ek)
    dE = Ek - Ektab

    # f2corr 
    def f2corr(a, b0, b1):
        return a + (b0 + b1*energy)*f2m
    
    weights = np.ones(len(energy))
    indleft = np.where(f2m>1.005*f2m[0])[0][0]
    indright = np.where(energy>(energy[iK]+100))[0][0]
    
    weights[:indleft] = 100
    weights[indright:] = 100
    def residuals(*v):
        if hasattr(v[0], "__iter__"): v = np.append(v[0], v[1:]).ravel()
        return (f2func(energy-v[0]) -  f2corr(*v[1:]))*weights
    
    fp = optimize.leastsq(residuals, [dE,0.,1.,0.])[0]
    print fp
    return f2corr(*fp[1:]), fp[0]
"""


class mu2fluo(object):
    """
        Calculates relative fluorescence intensity for a material of given
        composition and density for a known absorption coefficient ``mu`` 
        in a certain energy range.
    """
    def __init__(self, composition, resatom, energy, ene_fluo, density=1., dE=0., table="Sasaki"):
        assert(resatom in composition), "Resonant atom not found in composition."
        
        const = 10135467.657934014 # 2*eV/c/hbar
        self.energy = energy
        beta_nonres = pf.get_optical_constants(density, composition, energy - dE, table=table, feff={resatom:0})[1]
        beta_T = pf.get_optical_constants(density, composition, energy - dE, table=table)[1]
        self.weights = np.ones(len(energy))
        self.DAFS = None
        self.mu_nonres = beta_nonres * const * energy # nonresonant part of absorption
        self.mu_T = beta_T * const * energy # total absorption
        self.mu_fluo = pf.get_optical_constants(density, composition, ene_fluo, table=table)[1] * const * ene_fluo
        self.mu_res_tab = self.mu_T - self.mu_nonres # resonant part of absorption
        
        self.mu = et.lorentzian_filter1d(self.mu_res_tab, .5)
        try:
            iedge = np.diff(self.mu_res_tab).argmax()
            self.Eedge = energy[iedge]
            print("Found edge at %.1f eV"%self.Eedge)
        except:
            iedge=-1
            print("Could not find edge in data")
        
        if iedge!=-1:
            def parabola(x, l, m, n):
                return n + m*x + l*x**2
            
            xfit = np.log(energy[:iedge])
            yfit = np.log(self.mu_res_tab[:iedge])
            
            popt, pcov =  optimize.curve_fit(parabola, xfit, yfit, p0=(0,-3.7, 1.))
            
            self.mu_res_tab -= np.exp(parabola(np.log(energy), *popt)) # only lowest shell absorption
            self.mu_nonres += np.exp(parabola(np.log(energy), *popt))
        else:
            self.mu_res_tab -= mu_res_tab.min()
            self.mu_nonres += mu_res_tab.min()
        
        self.p = {"omega":0., "d":np.inf, "theta":45, "scaleF":1., "scale":1., "om_range":0, "m":0, "n":1., "c":1.}
        self.ind_mu = None # index of mu where it shall be fitted to tabulated data
        
        self.xval = np.linspace(-4, 4, 51)
        self.stdnorm = et.standard_normal(self.xval)
        self.muweight = 1.
        
    
    def getomega(self, omega=None, om_range=None):
        if omega==None:
            omega = self.p["omega"]
        if om_range==None:
            om_range = self.p["om_range"]
        if np.ndim(omega)==0:
            omega = np.array(omega, ndmin=2)
            if om_range!=0:
                omega = self.xval[:,np.newaxis] * om_range + omega
                parts = self.stdnorm[:,np.newaxis] * np.diff(self.xval)[0]
            else:
                parts = 1
        elif np.ndim(omega)==1:
            parts = np.ones(len(omega), dtype=float)[:,np.newaxis]
        elif np.ndim(omega)==2:
            parts = omega[:,0][:,np.newaxis]
            omega = omega[:,1][:,np.newaxis]
        else: 
            raise ValueError("omega has to many dimensions")
        parts/=np.sum(parts) # normalization
        
        return parts, omega
    
    def relfluo(self, mu_res=None, **kwargs):
        if mu_res == None:
            mu_res = self.mu
        mu_res = abs(mu_res)
        self.p.update(dict([i for i in kwargs.iteritems() if self.p.has_key(i[0])]))
        parts, omega = self.getomega()
        
        s_in = np.sin(np.radians(self.p["theta"] + omega)) # sine of incoming beam angle
        s_ou = np.sin(np.radians(self.p["theta"] - omega))
        
        
        Int =  parts * mu_res / (mu_res + self.mu_nonres + s_in/s_ou*self.mu_fluo) \
               * (1 - np.exp(-((self.mu_nonres + mu_res)/s_in + self.mu_fluo/s_ou) * self.p["d"]))
        return Int.sum(0)
    
    def getmu(self, Ifluo=None, muguess=None, **kwargs):
        if Ifluo==None:
            Ifluo = self.Ifluo
        else:
            self.Ifluo = Ifluo
        self.p.update(dict([i for i in kwargs.iteritems() if self.p.has_key(i[0])]))
        
        if muguess == None:
            muguess = self.mu
            #muguess = self.mu_res_tab.max()*Ifluo
        
        self.mu = abs(optimize.fsolve(lambda x: abs(self.relfluo(x) - abs(self.p["scaleF"])*Ifluo), muguess))
        
        self.mu_T = abs(self.mu) + self.mu_nonres
        return self.mu_T
    
    def AbsBragg(self, mu_T=None, pol="sigma", **kwargs):
        self.p.update(dict([i for i in kwargs.iteritems() if self.p.has_key(i[0])]))
        if pol=="sigma":
            LP = 1.
        else:
            pass #not yet
        parts, omega = self.getomega()
        
        Q = abs(self.p["scale"]) * LP
        if mu_T==None:
            mu_T = self.getmu()
        t_om = np.tan(np.radians(omega))
        t_th = np.tan(np.radians(self.p["theta"]))
        s_in = np.sin(np.radians(omega + self.p["theta"]))
        
        Int = parts * Q / (2*mu_T) * (1 - t_om/t_th) * (1 - np.exp(-2*mu_T*self.p["d"]/s_in/(1 - t_om/t_th)))
        
        return Int.sum(0)
    
    def residuals(self, **p):
        self.p.update(dict([i for i in p.iteritems() if self.p.has_key(i[0])]))
        
        """
        if "om_cen" in self.variables or "om_range" in self.variables:
            self.p["omega"] = pl.linspace(p["om_cen"] - p["om_range"]/2.,
                                          p["om_cen"] + p["om_range"]/2., 11)
        """
        self.corr = self.p["m"] * (self.energy - self.energy[0]) + self.p["n"] # lin Untergrund
        self.Abs = self.AbsBragg() / self.corr
        if self.DAFS==None:
            res1 = (self.Abs - self.IBragg) * self.weights
        else:
            res1 = (self.IBragg/self.Abs - self.DAFS) * self.weights
        
        self.muc = self.mu / self.corr**self.p["c"]
        if self.ind_mu!=None:
            res2 = (self.mu_res_tab[self.ind_mu] / self.muc[self.ind_mu] - 1.) * self.IBragg.mean() * self.muweight
            res = np.append(res1, res2)
        else:
            res = res1
        
        self.err = (res**2).sum()
        print self.err
        if self.fitalg == "simplex":
            return self.err
        else:
            return res
        
    def fitit(self, IBragg, variables, fitalg="leastsq"):
        self.fitalg = fitalg
        self.IBragg = IBragg
        self.variables = variables
        func, startval = wrap4leastsq.wrap_for_fit(self.residuals, self.p, variables)
        if self.fitalg == "simplex":
            output = optimize.fmin(func, startval, full_output=True, maxfun=1000*len(startval), maxiter=1000*len(startval))
        else:
            output = optimize.leastsq(func, startval, full_output=True, ftol=2**-20, xtol=2**-20)
        param = output[0]
        return param
        
def fluo_to_mu(composition, density, energy, fluorescence, order=1, dE=None,
               full_output=True, table="Sasaki"):
    """
        Fits a given fluorescence curve to the tabulated absorption 
        coefficient of any material for a given energy in the x-ray regime
        given in eV.
        Since the relation abscoeff(fluo) is rather non-trivial a polynomial 
        dependence up to a certain order<=2 is assumed. Furthermore, an energy
        dependence up to the same order is assumed du take account for the 
        energy dependent device function (absorption, source performance etc.).
        
        Inputs:
            composition : string
                Sum formula of the material.
            
            density : float
                Density of the material.
            
            energy : numpy.array
                Array of energy values.
            
            fluorescence : numpy.array
                Array of fluorescence intensities.
            
        Optional inputs:
            - order : int
                Order of the polynomial describing device function and 
                fluorescence vs. absorption dependence
            
            - dE : float
                Shift of edge position. Difference between measured and
                theoretical edge position.
            
            - full_output : bool
                If true, a dictionary containing additional information will
                be returned as second return value.
            
            - table : string
                Database table to be used for smooth dispersion corrections
                of free atom. See pyxrr.functions.get_optical_constants.__doc__
                for details.
        
        Returns:
            - mu : the fitted curve
            
            if full_output == True further output is generated:
                - dE : energy shift compared to the tabulated curves
                    (should be some few eV)
                    
                - mud_guess : the curve generated by the inital parameters.
                
                - mu_tab : the smooth absorption coefficient taken from the.
                    database.
                
                - param : the parameters that minimize the error function.
                
                - error : a list containing the value of the error function
                    for each iteration.
                
                - weights : weighting automatically generated by use of the
                    edge position.
    """
    fitfunc = optimize.fmin
    maxiter = 10000
    const = 10135467.657934014 # 2*e/c/hbar
    energy_ext = np.arange(energy[0]-100, energy[-1]+100, np.diff(energy).min())
    delta, beta = pf.get_optical_constants(density, composition, energy_ext, 
                                           table=table)
    mu = et.lorentzian_filter1d(const * energy_ext * beta, 2)
    #fluorescence = et.lorentzian_filter1d(fluorescence, 1)
    
    fluorescence -= fluorescence.min()
    
    dmu = np.diff(const * energy_ext * beta)
    ind = abs(dmu) > 10*abs(np.median(dmu))
    Eedge = energy_ext[np.where(ind==True)]
    ind = np.zeros(len(energy), dtype=bool)
    first = 1
    for E in Eedge:
        ind += (energy>(E - 20.)) * (energy<(E + 100.))
        if first:
            if dE==None:
                imax = np.diff(fluorescence[ind]).argmax()
                dE =  energy[ind][[imax, imax+1]].mean() - E
            ind = (energy>(E + dE - 20.)) * (energy<(E + dE + 100.))
            first = 0
            print("Energy shift: %.1f eV"%dE)
        print("Edge at %.2f eV"%E)
    weights = np.ones(len(energy))
    weights[~ind] *= 15.
    mufunc = interpolate.interp1d(energy_ext + dE, mu, bounds_error=False, 
                                  fill_value=np.nan)
    
    def mud(a0, a1, b0, ab0, b1, ab1):
        #return (1 + b1*energy + c0*energy**2) * \
        #       (a0 + b2*fluorescence + c1*fluorescence**2 + d1*fluorescence**3)
        return a0 \
             + a1 * fluorescence \
             + b0 * (energy - energy[0]) \
             + ab0 * (energy - energy[0]) * fluorescence \
             + b1 * (energy - energy[0])**2 \
             + ab1 * (energy - energy[0])**2 * fluorescence
    
    errs = []
    def residuals(*v):
        if hasattr(v[0], "__iter__"): v = np.append(v[0], v[1:]).ravel()
        res = (mufunc(energy) -  mud(*v)) * weights
        errs.append((res**2).sum())#, v #show error on every step
        #return res
        return (res**2).sum()
    
    #fp = optimize.fmin(residuals, [0,0.,1.,0.])[0]
    
    guess = [mu.min(),
             (mu.mean() - mu.min())/fluorescence.mean(),
             np.median(dmu)/np.median(np.diff(energy)),
             0.]
    
    if order>=1:
        fp = fitfunc(residuals, 
                     guess,
                     args = [ 0., 0.], maxiter=maxiter, maxfun=maxiter)
        fp = np.append(fp, [0,0])
    if order>=2:
        #fp = np.append(guess, [0,0])
        fp = fitfunc(residuals, fp, maxiter=maxiter, maxfun=maxiter)
    #print "Fit result:\n", fp
    if full_output:
        fullout = {"mu_tab": mufunc(energy), 
                   "mud_guess": mud(*(guess + [0,0])), 
                   "dE":dE,
                   "param":fp, 
                   "error":np.array(errs), 
                   "weights":weights}
        return mud(*fp), fullout
    else:
        return mud(*fp)


"""
class fluospec(object):
    def __init__(self, material, dE = None, DB_Table="Sasaki"):
        self.material = material
        comp, n = pf.get_components(material)
        if dE == None:
            dE = [0]*len(comp)
        self.f1, self.f2 = {}
        for element in comp[0]:
            E, f1, f2 = get_f1f2_from_db(element, table = DB_Table).T
            mufunc = interpolate.interp1d(E, f1, bounds_error=False, fill_value=np.nan)
        

"""



def mu_to_f2(composition, resatom, energy, mu, density=1., table = "Sasaki"):
    """
        Uses the measured absolute absorption coefficient ``mu`` of a material
        of known ``composition`` and ``density`` and extracts the imaginary part 
        of the scattering amplitude of the resonant atom ``resatom`` and in a 
        given ``energy`` range.by substraction of the other elements.
        
        Inputs:
            - composition : string
                The sum formula of the material.
            
            - resatom : string
                Abbreviation of the resonant atom.
            
            - energy : numpy.array
                Array of measured energies in eV.
            
            - mu : numpy.array
                Array of absolute measured absorption coefficient
                e.g. the result of the fluo_to_mu function.
            
            - density : float
                Density of the material.
            
            - table : string
                Database table to be used for smooth dispersion corrections
                of free atom. See pyxrr.functions.get_optical_constants.__doc__
                for details.
            
        
        Outputs: A (f2, f2smooth) tuple
            - f2 : numpy.array
                Array containing the resulting fine structure of the imaginary
                part of the atoming scattering amplitude.
            
            - f2smooth : numpy.array
                Array containing the smooth free atom part from tables.
    """
    elements, amount = pf.get_components(composition)
    amount = np.array(amount)
    weights = [pf.get_element(element)[1]/1000. for element in elements]
    const = 10135467.657934014 # 2*e/c/hbar
    beta = mu / const / energy
    
    beta /= pf.electron_radius/(2*np.pi) * (pf.keV_A*1e-7/energy)**2 * density*1000. * pf.avogadro / (amount*weights).sum()
    for i in range(len(elements)):
        E, f1, f2 = np.array(pf.get_f1f2_from_db(elements[i], table=table)).T
        f2func = interpolate.interp1d(E, f2, bounds_error=False)
        if elements[i]==resatom:
            f2smooth = f2func(energy)
        else:
            beta  -= f2func(energy) * amount[i]
    f2 = beta / amount[elements.index(resatom)]
    return f2, f2smooth


def rebin_k_space(energy, xafs, edge, dist=10, conststep=True):
    """
        A smoothing filter for EXAFS data. It works as a moving 
        box average with variable window size corresponding to a
        constant with in electron k-space.
        
        Inputs:
            energy : numpy.array
                Array of energy values.
            
            xafs : numpy.array
                Array of intensity values.
            
            edge : float
                Absorption edge energy. Here the electron wave
                vector k equals zero.
            
            dist : float
                distance beyond the edge, where smoothing shall
                start.
            
            conststep : bool
                True if returned result shall be equally spaced
                in energy instead of k
            
        Outputs:
            A 2-tuple containing the resulting, smoothed
            (energy, xafs) arrays.
        
    """
    newene = energy.copy()
    a = dist
    ind = energy > (edge + dist)
    newene[ind] = np.sqrt(2.*a*(energy[ind] - edge) - a**2) + edge
    
    data = np.vstack((newene, xafs)).T
    esmooth, xafssmooth = pf.rebin_data(data[ind], np.diff(newene[~ind])[0]).T
    esmooth = edge + ((esmooth - edge)**2 + a**2)/(2*a)
    esmooth = np.append(energy[~ind], esmooth)
    xafssmooth = np.append(xafs[~ind], xafssmooth)
    #ind = esmooth > (edge + dist)
    if conststep:
        xafsfunc = interpolate.interp1d(esmooth, xafssmooth, kind="cubic", bounds_error=False)
        #xafssmooth = xafsfunc(energy)
        xafs = xafsfunc(energy)
        print xafs.shape
        #xafs = np.append(xafs[~ind], xafssmooth)
        return energy, xafs
    else:
        return esmooth, xafssmooth


